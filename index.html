<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D New Year's Dumpster Fire</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto+Mono:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Roboto Mono', monospace;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #overlay-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding-top: 3vh; /* Slightly less padding from the very top */
            color: #fff;
            text-shadow: 0 0 15px rgba(0,0,0,1);
        }

        #countdown {
            font-size: 8vw;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 10px;
            /* Added margin to push the dumpster visual further down relative to text */
            margin-top: 2vh; 
        }

        .label {
            font-size: 1.5vw;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            opacity: 0.9;
            background: rgba(0,0,0,0.5);
            padding: 8px 24px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        @media (max-width: 768px) {
            #countdown { font-size: 12vw; margin-top: 5vh; }
            .label { font-size: 4vw; }
        }
    </style>
</head>
<body>

    <div id="overlay-container">
        <div class="label">Time Until Collapse</div>
        <div id="countdown">00:00:00:00</div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP ---
        const currentYear = new Date().getFullYear().toString();
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a0a, 0.04);
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        // Adjusted camera slightly to provide better vertical clearance for the UI
        camera.position.set(0, 2.0, 8.0);
        camera.lookAt(0, 1.2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); 
        scene.add(ambientLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 2.0);
        rimLight.position.set(0, 5, -5);
        scene.add(rimLight);

        const fireLight = new THREE.PointLight(0xff4500, 25, 15);
        fireLight.position.set(0, 1.8, 0);
        fireLight.castShadow = true;
        scene.add(fireLight);

        // --- 3. DUMPSTER ---
        const dumpsterGroup = new THREE.Group();
        scene.add(dumpsterGroup);

        const metalMat = new THREE.MeshStandardMaterial({
            color: 0x2d5a27, 
            roughness: 0.5,
            metalness: 0.5,
        });

        const body = new THREE.Mesh(new THREE.BoxGeometry(3.2, 1.8, 2.2), metalMat);
        body.position.y = 1.1;
        body.castShadow = true;
        dumpsterGroup.add(body);

        const ribGeo = new THREE.BoxGeometry(0.12, 1.7, 0.15);
        for(let i = -1; i <= 1; i++) {
            const rL = new THREE.Mesh(ribGeo, metalMat);
            rL.position.set(-1.65, 1.1, i * 0.7);
            dumpsterGroup.add(rL);
            const rR = new THREE.Mesh(ribGeo, metalMat);
            rR.position.set(1.65, 1.1, i * 0.7);
            dumpsterGroup.add(rR);
        }

        const sleeve = new THREE.Mesh(new THREE.BoxGeometry(3.3, 0.3, 0.3), metalMat);
        sleeve.position.set(0, 0.8, 1.1);
        dumpsterGroup.add(sleeve);

        const lidGeo = new THREE.BoxGeometry(1.6, 0.1, 2.3);
        const lidMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
        const lidL = new THREE.Mesh(lidGeo, lidMat);
        lidL.position.set(-0.8, 2.0, -0.5);
        lidL.rotation.x = -Math.PI / 3;
        dumpsterGroup.add(lidL);

        // --- 4. GRAFFITI ---
        function createSprayTexture(text) {
            const cvs = document.createElement('canvas');
            cvs.width = 1024; cvs.height = 512;
            const ctx = cvs.getContext('2d');
            ctx.clearRect(0,0,1024,512);
            ctx.font = '900 220px "Black Ops One", system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#ff0044';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ff0044';
            ctx.translate(512, 200); 
            ctx.rotate(-0.05);
            ctx.fillText(text, 0, 0);
            ctx.shadowBlur = 0;
            for(let i = 0; i < 10; i++) {
                const dx = (Math.random() - 0.5) * 600;
                const dy = 50 + (Math.random() * 20);
                const dl = 100 + Math.random() * 200;
                ctx.beginPath();
                ctx.lineWidth = 5 + Math.random() * 8;
                ctx.lineCap = 'round';
                ctx.moveTo(dx, dy);
                ctx.lineTo(dx, dy + dl);
                ctx.strokeStyle = '#ff0044';
                ctx.stroke();
            }
            return new THREE.CanvasTexture(cvs);
        }

        const grafPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 1.5), 
            new THREE.MeshBasicMaterial({ map: createSprayTexture(currentYear), transparent: true, opacity: 0.85 })
        );
        grafPlane.position.set(0, 1.35, 1.11);
        dumpsterGroup.add(grafPlane);

        // --- 5. CHRISTMAS LIGHTS ---
        const lightColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
        const stringPoints = [];
        for (let i = 0; i <= 20; i++) {
            const x = -1.8 + (i * 0.18);
            const y = 1.9 + Math.sin(i * 0.8) * 0.15;
            const z = 1.15;
            stringPoints.push(new THREE.Vector3(x, y, z));
            
            const bulbGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const bulbMat = new THREE.MeshStandardMaterial({ 
                color: lightColors[i % lightColors.length],
                emissive: lightColors[i % lightColors.length],
                emissiveIntensity: 2
            });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(x, y, z);
            dumpsterGroup.add(bulb);
            
            if (i % 4 === 0) {
                const pLight = new THREE.PointLight(lightColors[i % lightColors.length], 0.5, 1);
                pLight.position.set(x, y, z + 0.1);
                dumpsterGroup.add(pLight);
            }
        }
        const stringGeo = new THREE.BufferGeometry().setFromPoints(stringPoints);
        const stringMat = new THREE.LineBasicMaterial({ color: 0x111111 });
        const string = new THREE.Line(stringGeo, stringMat);
        dumpsterGroup.add(string);

        // --- 6. PARTICLE SYSTEMS ---
        function createCircleTexture(color, isGlow = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            if (isGlow) {
                grad.addColorStop(0, color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
            } else {
                grad.addColorStop(0, color);
                grad.addColorStop(0.5, color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const fireCount = 120;
        const fireGeo = new THREE.BufferGeometry();
        const firePos = new Float32Array(fireCount * 3);
        const fireSpeeds = new Float32Array(fireCount);
        for(let i=0; i<fireCount; i++) {
            firePos[i*3] = (Math.random()-0.5) * 2.2;
            firePos[i*3+1] = 1.2 + Math.random();
            firePos[i*3+2] = (Math.random()-0.5) * 1.5;
            fireSpeeds[i] = 0.04 + Math.random() * 0.04;
        }
        fireGeo.setAttribute('position', new THREE.BufferAttribute(firePos, 3));
        const fireMat = new THREE.PointsMaterial({
            size: 1.6,
            map: createCircleTexture('rgba(255,100,20,1)', true),
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const fireParticles = new THREE.Points(fireGeo, fireMat);
        dumpsterGroup.add(fireParticles);

        const smokeCount = 90;
        const smokeGeo = new THREE.BufferGeometry();
        const smokePos = new Float32Array(smokeCount * 3);
        const smokeSpeeds = new Float32Array(smokeCount);
        for(let i=0; i<smokeCount; i++) {
            smokePos[i*3] = (Math.random()-0.5) * 2.5;
            smokePos[i*3+1] = 2 + Math.random() * 4;
            smokePos[i*3+2] = (Math.random()-0.5) * 1.5;
            smokeSpeeds[i] = 0.01 + Math.random() * 0.02;
        }
        smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
        const smokeMat = new THREE.PointsMaterial({
            size: 3.8,
            map: createCircleTexture('rgba(60,60,60,0.4)', true),
            transparent: true,
            depthWrite: false,
            opacity: 0.4
        });
        const smokeParticles = new THREE.Points(smokeGeo, smokeMat);
        dumpsterGroup.add(smokeParticles);

        const emberCount = 60;
        const emberGeo = new THREE.BufferGeometry();
        const emberPos = new Float32Array(emberCount * 3);
        const emberSpeeds = new Float32Array(emberCount);
        for(let i=0; i<emberCount; i++) {
            emberPos[i*3] = (Math.random()-0.5) * 2.2;
            emberPos[i*3+1] = 1.2;
            emberPos[i*3+2] = (Math.random()-0.5) * 1.5;
            emberSpeeds[i] = 0.05 + Math.random() * 0.12;
        }
        emberGeo.setAttribute('position', new THREE.BufferAttribute(emberPos, 3));
        const emberMat = new THREE.PointsMaterial({
            size: 0.18,
            color: 0xffcc44,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const emberParticles = new THREE.Points(emberGeo, emberMat);
        dumpsterGroup.add(emberParticles);

        // --- 7. ANIMATION LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            fireLight.intensity = 22 + Math.sin(t * 15) * 10;
            fireLight.position.x = Math.sin(t * 5) * 0.2;

            const fPos = fireGeo.attributes.position.array;
            for(let i=0; i<fireCount; i++) {
                fPos[i*3+1] += fireSpeeds[i];
                fPos[i*3] += Math.sin(t + i) * 0.005;
                if(fPos[i*3+1] > 4.5) {
                    fPos[i*3+1] = 1.2;
                    fPos[i*3] = (Math.random()-0.5) * 2.2;
                }
            }
            fireGeo.attributes.position.needsUpdate = true;

            const sPos = smokeGeo.attributes.position.array;
            for(let i=0; i<smokeCount; i++) {
                sPos[i*3+1] += smokeSpeeds[i];
                if(sPos[i*3+1] > 9) {
                    sPos[i*3+1] = 2;
                }
            }
            smokeGeo.attributes.position.needsUpdate = true;

            const ePos = emberGeo.attributes.position.array;
            for(let i=0; i<emberCount; i++) {
                ePos[i*3+1] += emberSpeeds[i];
                if(ePos[i*3+1] > 7) {
                    ePos[i*3+1] = 1.2;
                }
            }
            emberGeo.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // --- 8. UTILS ---
        function updateTimer() {
            const nextYear = new Date(`January 1, ${parseInt(currentYear) + 1} 00:00:00`).getTime();
            const now = new Date().getTime();
            const gap = nextYear - now;

            if (gap < 0) {
                document.getElementById('countdown').innerHTML = "HAPPY NEW YEAR!";
            } else {
                const days = Math.floor(gap / (1000 * 60 * 60 * 24));
                const hours = Math.floor((gap % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((gap % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((gap % (1000 * 60)) / 1000);

                const dayStr = days > 0 ? days + "d " : "";
                document.getElementById('countdown').innerHTML = 
                    `${dayStr}${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        setInterval(updateTimer, 1000);
        updateTimer();
        animate();
    </script>
</body>
</html>
